DISABLE_MAGIC_FUNCTIONS=true # disable magic functions
fpath=(~/.zsh/completion $fpath) # add custom completions
setopt histignorespace # ignore commands that start with a space
set -o vi
bindkey '^H' backward-kill-word # Ctrl + Backspace (delete word)
bindkey -e # use emacs keybindings

# history setup
setopt SHARE_HISTORY
HISTFILE=$HOME/.zhistory
SAVEHIST=1000
HISTSIZE=999
setopt HIST_EXPIRE_DUPS_FIRST
bindkey '^[OA' history-search-backward
bindkey '^[OB' history-search-forward

eval "$(fasd --init auto)" # init fasd

alias ls="eza -l --group-directories-first -s type --git --git-ignore"
alias r='cd $(git rev-parse --show-toplevel)' # go to git root
alias g='git'
alias k='kubectl'
alias cat='bat'
alias rg="rg --hidden"
alias yt="youtube-dl"

# fd is fdfind in linux `apt install fd-find`
if [[ `uname` == "Linux" ]]; then
  alias fd='fdfind'
fi

# make dir and enter it
function mkc() {
  mkdir -p "$@" && cd "$@"
}

# fasd & fzf change directory - jump using `fasd` if given argument, filter output of `fasd` using `fzf` else
function z() {
  local dir
  dir="$(fasd -Rdl "$1" | fzf -1 -0 --no-sort +m)" && cd "${dir}" || return 1
}

export MANPATH="/usr/local/man:$MANPATH"
export EDITOR=$(which nvim)
export DOCKER_BUILDKIT=1
export GOPATH=$HOME/go
# export FZF_DEFAULT_COMMAND="fd --type d"
# export FZF_CTRL_T_COMMAND="$FZF_DEFAULT_COMMAND"
export GPG_TTY=$(tty)
export PATH=$PATH:/usr/local/go/bin # ubuntu go installation
export PATH=$PATH:~/.local/bin # windows custom bin path
export PATH="$HOME/.yarn/bin:$PATH"
export PATH="$HOME/n/bin:$PATH"
export PATH=$PATH:$GOPATH/bin
export PATH=$PATH:/usr/local/opt/go/libexec/bin
export PATH=$PATH:/Applications/Postgres.app/Contents/Versions/latest/bin
export PATH=$PATH:/Applications/Visual\ Studio\ Code.app/Contents/Resources/app/bin
export PATH="/usr/local/Cellar/gnu-getopt/1.1.6/bin":$PATH # Use gnu getopts
export N_PREFIX="$HOME/n"; [[ :$PATH: == *":$N_PREFIX/bin:"* ]] || PATH+=":$N_PREFIX/bin"  # Added by n-install (see http://git.io/n-install-repo).
export PYENV_ROOT="$HOME/.pyenv"
export PATH="$PYENV_ROOT/bin:$PATH"
export NIX_PATH=$HOME/.nix-defexpr/channels${NIX_PATH:+:}$NIX_PATH # nix HOME MANAGER
export DIRENV_LOG_FORMAT="" # disable direnv logging

[[ -e ~/.ssh/github_rsa ]] && ssh-add ~/.ssh/github_rsa # automatically add non default ssh keys

# Base16 Shell
BASE16_SHELL="$HOME/.config/base16-shell/"
[ -n "$PS1" ] && \
    [ -s "$BASE16_SHELL/profile_helper.sh" ] && \
        source "$BASE16_SHELL/profile_helper.sh"

[[ -f ~/.dotfiles/secrets/env ]] && source ~/.dotfiles/secrets/env

# NIX HOME MANAGER
source "$HOME/.nix-profile/etc/profile.d/hm-session-vars.sh"

if [ -e $HOME/.nix-profile/etc/profile.d/nix.sh ]; then . $HOME/.nix-profile/etc/profile.d/nix.sh; fi # added by Nix installer
# TODO within tmux the PATH is being configured twice by something else, I tried
# removing all contents from zshrc and tmux.conf and it still happens. So this
# is a workaround to fix the PATH in tmux sessions
export PATH="$HOME/.nix-profile/bin:$HOME/.nix-profile/sbin:$PATH" # added by Nix installer
eval "$(direnv hook zsh)"

# tmux ssh session
if [[ -n "$PS1" ]] && [[ -z "$TMUX" ]] && [[ -n "$SSH_CONNECTION" ]]; then
  tmux attach-session -t ssh_tmux || tmux new-session -s ssh_tmux
fi

# This has to be at the bottom for it to work need to figure out what is
# overriding this if i put it in the start of the file
bindkey '^[[1;2D' backward-word # Shift + Left Arrow (move word left)
bindkey '^[[1;2C' forward-word # Shift + Right Arrow (move word right)



vst3_doctor() {
  # Usage: vst3_doctor "Plugin.vst3"  OR  vst3_doctor "/Library/Audio/Plug-Ins/VST3/Plugin.vst3"
  local input="$*"
  if [[ -z "$input" ]]; then
    echo "Usage: vst3_doctor <plugin .vst3 path or name>"
    return 1
  fi

  # Pretty section header
  _vst3hdr() { printf "\n\033[1m==> %s\033[0m\n" "$1"; }

  # Resolve plugin path (PWD, user VST3, system VST3)
  local plugin="$input"
  if [[ ! -e "$plugin" ]]; then
    if [[ -e "$PWD/$input" ]]; then
      plugin="$PWD/$input"
    elif [[ -e "$HOME/Library/Audio/Plug-Ins/VST3/$input" ]]; then
      plugin="$HOME/Library/Audio/Plug-Ins/VST3/$input"
    elif [[ -e "/Library/Audio/Plug-Ins/VST3/$input" ]]; then
      plugin="/Library/Audio/Plug-Ins/VST3/$input"
    else
      echo "❌ Could not find: $input"
      echo "   Checked:"
      echo "     - $PWD/$input"
      echo "     - $HOME/Library/Audio/Plug-Ins/VST3/$input"
      echo "     - /Library/Audio/Plug-Ins/VST3/$input"
      return 1
    fi
  fi

  # Require .vst3 bundle
  if [[ "${plugin##*.}" != "vst3" ]]; then
    echo "❌ Not a .vst3 bundle: $plugin"
    return 1
  fi

  # Sudo when touching system bundle
  local asudo=""
  if [[ "$plugin" == /Library/* ]] && [[ ! -w "$plugin" ]]; then
    asudo="sudo"
  fi

  _vst3hdr "Target"
  echo "Bundle: $plugin"

  # Expect standard structure
  local contents="$plugin/Contents"
  local macos="$contents/MacOS"
  local info="$contents/Info.plist"
  if [[ ! -d "$contents" || ! -d "$macos" || ! -f "$info" ]]; then
    echo "❌ Malformed bundle. Expected:"
    echo "   $plugin/Contents/"
    echo "   $plugin/Contents/MacOS/<binary>"
    echo "   $plugin/Contents/Info.plist"
    return 1
  fi

  _vst3hdr "Info.plist sanity"
  /usr/bin/plutil -p "$info" 2>/dev/null | /usr/bin/egrep 'CFBundleIdentifier|CFBundleExecutable|CFBundlePackageType|CFBundleVersion' || true

  # Read executable name
  local exe
  exe=$(/usr/bin/defaults read "${contents}/Info" CFBundleExecutable 2>/dev/null)
  if [[ -z "$exe" ]]; then
    echo "❌ CFBundleExecutable missing in Info.plist"
    return 1
  fi
  local exepath="$macos/$exe"
  echo "Executable: $exepath"

  # Ensure executable exists and is +x
  if [[ ! -f "$exepath" ]]; then
    echo "❌ Executable file not found at $exepath"
    return 1
  fi
  if [[ ! -x "$exepath" ]]; then
    _vst3hdr "Fix: make executable"
    $asudo /bin/chmod +x "$exepath" || { echo "❌ chmod failed"; return 1; }
  fi

  _vst3hdr "Architectures"
  /usr/bin/file "$macos"/* || true
  local host_arch
  host_arch=$(/usr/bin/uname -m)
  echo "Host shell arch: $host_arch"
  echo "Note: Your DAW may run under Rosetta (x86_64) even on Apple Silicon."

  _vst3hdr "Clear quarantine / extended attributes"
  if ! $asudo /usr/bin/xattr -cr "$plugin"; then
    echo "⚠️  xattr failed (may be harmless)";
  else
    echo "✓ xattr cleared"
  fi

  _vst3hdr "Ad-hoc code sign"
  # Try deep ad-hoc sign; if it fails, try without --deep as fallback
  if $asudo /usr/bin/codesign --force --deep --sign - "$plugin" 2>/dev/null; then
    echo "✓ codesign (deep) OK"
  else
    echo "… retrying without --deep"
    if ! $asudo /usr/bin/codesign --force --sign - "$plugin"; then
      echo "❌ codesign failed"
      return 1
    fi
  fi

  _vst3hdr "Verify signature"
  if /usr/bin/codesign -dv --verbose=4 "$plugin" >/dev/null 2>&1; then
    /usr/bin/codesign -dv --verbose=4 "$plugin" 2>&1 | sed 's/^/  /'
  else
    echo "❌ Verification failed"
    return 1
  fi

  _vst3hdr "Gatekeeper assessment"
  # Assess the main executable (better signal than bundle)
  if /usr/sbin/spctl --assess --type execute -vv "$exepath" >/dev/null 2>&1; then
    /usr/sbin/spctl --assess --type execute -vv "$exepath" 2>&1 | sed 's/^/  /'
  else
    echo "⚠️  spctl reports rejected (often okay for ad-hoc signatures). Details:"
    /usr/sbin/spctl --assess --type execute -vv "$exepath" 2>&1 | sed 's/^/  /'
  fi

  _vst3hdr "Common blockers (quick hints)"
  echo "• If 'file' shows x86_64 only and your DAW is native arm64, launch the DAW with Rosetta (Get Info → Open using Rosetta) and rescan."
  echo "• Ensure the bundle is in one of these paths (most DAWs scan the system path by default):"
  echo "    ~/Library/Audio/Plug-Ins/VST3"
  echo "    /Library/Audio/Plug-Ins/VST3"
  echo "• After this, force a FULL rescan in your DAW's plug-in manager."

  _vst3hdr "Done"
  echo "If it still won’t appear, check your DAW’s scan log (e.g., Ableton: ~/Library/Preferences/Ableton/Live */Log.txt)."
}
