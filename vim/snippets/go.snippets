snippet for
for $1:=0; $1<$2; $1++ {
	$0
}
endsnippet

snippet forin
for $1, $2 := range $3 {
	$0
}
endsnippet

snippet range
for ${1:_, val} := range $2 {
	$0
}
endsnippet

snippet switch
switch $1 {

}
endsnippet

snippet case
case $1:
	$0
endsnippet

snippet if
if $1 {
	$0
}
endsnippet

snippet struct
type $1 struct {
	$0
}
endsnippet

snippet interface
type $1 interface {
	$0
}
endsnippet

snippet printf
fmt.Printf("$1", $2)
endsnippet

snippet print
fmt.Println("$1")
endsnippet

snippet init
package main

import (
	$1
)

func main() {
	$2
}
endsnippet

snippet fun
func ${2:name}(${3:args}) (${4:ret}) {
	$0
}
endsnippet

snippet rec "func (receiver) name(args) (ret) {}"
func (${1:receiver}) ${2:name}(${3:args}) (${4:ret}) {
	$0
}
endsnippet

snippet imp
import (
	$1
)
endsnippet

snippet err
if err != nil {
	log.Panic(${1:err})
}
endsnippet

snippet handler "func(w http.ResponseWriter, r *http.Request) {}"
func(w http.ResponseWriter, r *http.Request) {
	$0
}
endsnippet

snippet httperror
if err != nil {
	http.Error(w, ${1:err.Error()}, ${2:http.StatusInternalServerError})
	return
}
endsnippet

snippet testinit
package jwt

import (
	"testing"
)

func Test$1(t *testing.T) {
	type input struct {
		$2
	}
	type expect struct {
		$3
	}
	tests := []struct {
		label    string
		pass     bool
		input    input
		expected expect
	}{
		{}
	}

	for _, tc := range tests {
		t.Run(tc.label, func(t *testing.T) {
			// test assertions here
		})
	}
}
endsnippet

snippet decodejson
var result map[string]interface{}
json.NewDecoder(${1:io.Reader}).Decode(&result)
endsnippet

snippet fatal
if err != nil {
	t.Fatal(err)
}
endsnippet

snippet marshal
jsonByte, err := json.Marshal(${1:struct})
if err != nil {
	panic(fmt.Errorf("fatal error: %s", err))
}
endsnippet

snippet unmarshal
err := json.Unmarshal(${1:[]byte}, ${2:&struct})
if err != nil {
	panic(fmt.Errorf("fatal error: %s", err))
}
endsnippet
